<!DOCTYPE html>

<!-- Виктор Пъжев, група 7, ф.н. 4MI0800503 -->

<html>
	<head>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
		<script type="importmap">
			{ 
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
					"domus-mea": "https://cdn.jsdelivr.net/gh/boytchev/CourseOKG@latest/domus-mea.js",
					"csg/": "https://cdn.jsdelivr.net/gh/looeee/threejs-csg@main/src/CSG/"
				} 
			}
		</script>
	</head>
	
	<body>

		<script type="module">
			import * as THREE from "three";
			import {domusMea, scene, renderer, camera} from "domus-mea";
			import {CSG} from "csg/CSG.js";

			domusMea( '4MI0800503' ); // факултетен номер 
			
			// 1. преименувайте файла на moidom-g-fn.html
			//    g=номер на група, а fn=факултетен номер
			//
			// 2. първо сменете параметъра на domusMea да
			//    е факултетният ви номер - по този начин
			//    ще се генерират сцена, земя и контур на
			//    къщата ви, която ще трябва да направите
			//
			// 3. едва тогава почвайте да строите стените
			//    и да добавяте исканите обекти по стаите
			//
			// 4. кубът по-долу е само за пример как може
			//    да се слагат обекти, които правят сянка
			//
			// 5. едно зелено квадратче е широко 1 метър,
			//    а белите квадратчета са големи по 20 см
			//
			// 6. горд съм как коментарите са равно дълги

			const smallTile = 0.2;
			const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x99b084 });

			const walls = [
				createWall(-2.5 * smallTile, 5 - smallTile / 2, smallTile, 13),
				createWall(-2.5 * smallTile - 4, smallTile / 2 - 1, smallTile, 5),
				createWall(1, smallTile / 2 - 7, smallTile, 6),
				createWall(5, smallTile / 2 - 1, smallTile, 2),
				createWall(smallTile / 2 - 7, 2, 6, smallTile),
				createWall(6 - smallTile / 2, 2, 6, smallTile),
				createWall(4 - smallTile / 2, smallTile - 4, 6, smallTile),
				createWall(smallTile / 2 - 2, smallTile - 4, 6, smallTile),
				createWall(3 - smallTile / 4, smallTile / 2 - 5, smallTile, 2 + smallTile / 2),
				createWall(-1 + smallTile / 4, smallTile / 2 - 3, smallTile, 2 + smallTile / 2),
				createWall(1, smallTile / 2 - 4, smallTile * Math.sqrt(2), 2 * Math.sqrt(2), Math.PI / 4),
				createWall(-2.5 * smallTile - 5, smallTile / 2 + 2, smallTile, 3),
				createWall(3 + smallTile / 2 - 7, 2, 6, smallTile),
				createCircularWall(4, 1, 2, smallTile, Math.PI),
				createWall(9 + smallTile / 2 - 7, 3, 4, smallTile),
			];

			walls.forEach(w => scene.add(w));

			// const light = new THREE.PointLight();
			// light.position.set(0, 1, -3)
			// scene.add(light)

			function createWall(x, z, width, length, rot = 0) {
				const wall = new THREE.Mesh(
					new THREE.BoxGeometry(length, 2.4, width),
					wallMaterial
				);

				wall.position.set(x, 1.1, z);
				wall.rotation.y = rot;
				
				wall.receiveShadow = true;
				wall.castShadow = true;

				return wall;
			}

			function createCircularWall(x, z, r, width, rot = 0) {
				let wall = new THREE.Mesh(
					new THREE.CylinderGeometry(r, r, 2.4, 32, 1, false, 0, Math.PI / 2),
					wallMaterial
				);

				const wallHole = new THREE.Mesh(
					new THREE.CylinderGeometry(r - width, r - width, 2.4, 32, 1, false, 0, Math.PI / 2),
					wallMaterial
				);

				const csg = new CSG();
				csg.subtract([wall, wallHole]);
				wall = csg.toMesh();


				wall.position.set(x, 1.1, z);
				wall.rotation.y = rot;
				
				wall.receiveShadow = true;
				wall.castShadow = true;

				return wall;
			}
			
			function createToaster(x = 0, y = 0, z = 0, scale = 1, rotX = 0, rotY = 0, rotZ = 0) {
				const geometry = new THREE.BoxGeometry(smallTile, smallTile * 0.3, smallTile * 0.5);
				const material = new THREE.MeshPhongMaterial({ color: 'silver' });

				let toaster = new THREE.Mesh(geometry, material);

				const upper = new THREE.Mesh(new THREE.CylinderGeometry(smallTile * 0.5, smallTile * 0.5, smallTile * 0.5, 32, 32), material);
				upper.rotation.x = Math.PI / 2;
				upper.position.y = smallTile * 0.15;
				upper.scale.z = 0.3;

				const hole1 = new THREE.Mesh(new THREE.BoxGeometry(smallTile * 0.8, smallTile * 0.3, smallTile * 0.09));
				hole1.position.y = smallTile * 0.15;
				hole1.position.z = smallTile * 0.1;

				const hole2 = hole1.clone();
				hole1.position.y = smallTile * 0.15;
				hole1.position.z = -smallTile * 0.1;

				const csg = new CSG();
				csg.union([toaster, upper]);
				csg.subtract([hole1, hole2]);
				toaster = csg.toMesh();

				const button = new THREE.Mesh(
					new THREE.CylinderGeometry(smallTile * 0.1, smallTile * 0.1, smallTile * 0.05, 32, 32), 
					new THREE.MeshPhongMaterial({ color: 'black' }));
				button.position.set(smallTile * 0.5, smallTile * 0.1, 0);
				button.scale.z = 0.8;
				button.receiveShadow = true;
				button.castShadow = true;
				toaster.add(button);

				const lower = new THREE.Mesh(
					new THREE.BoxGeometry(smallTile * 1.02, smallTile * 0.1, smallTile * 0.5 * 1.02), 
					new THREE.MeshPhongMaterial({ color: 'black' }));
				lower.position.y = smallTile * 0.05 - smallTile * 0.15;
				lower.receiveShadow = true;
				lower.castShadow = true;
				toaster.add(lower);

				toaster.rotation.set(rotX, rotY, rotZ);
				toaster.position.set(x, y + smallTile * 0.15 * scale, z);
				toaster.scale.set(scale, scale, scale);

				toaster.receiveShadow = true;
				toaster.castShadow = true;

				return toaster;
			}

			function createMirror(x = 0, y = 0, z = 0, scale = 1, rotX = 0, rotY = 0, rotZ = 0) {
				const width = 3 * smallTile, height = 1.8;
				const mirrorShape = new THREE.Shape();

				mirrorShape.moveTo(0, width / 4, 0);
				mirrorShape.lineTo(0, height - 0.5, 0);
				mirrorShape.arc(width / 2, 0, width / 2, Math.PI, 0, true);
				mirrorShape.lineTo(width, width / 4, 0);
				mirrorShape.arc(-width / 4, 0, width / 4, 0, -Math.PI / 2, true);
				mirrorShape.lineTo(width / 4, 0, 0);
				mirrorShape.arc(0, width / 4, width / 4, -Math.PI / 2, -Math.PI + 0.1, true);

				let geometry = new THREE.ExtrudeGeometry(mirrorShape, { 
					depth: 0.01, 
					bevelEnabled: true, 
					bevelSegments: 2, 
					steps: 2, 
					bevelSize: 0.01, 
					bevelThickness: 0.01 
				});

				const material = new THREE.MeshPhongMaterial({ color: "silver" });

				const mirror = new THREE.Mesh(geometry, material);

				const reflection = mirror.clone();
				reflection.material = new THREE.MeshBasicMaterial({ color: 0xefefef });

				const offset = 0.95;
				reflection.scale.set(offset, offset, offset);
				reflection.position.set(width * (1 - offset) / 2, height * (1 - offset) / 2, 0.005);
				mirror.add(reflection);

				mirror.rotation.x = -Math.PI / 12;

				const standShape = new THREE.Shape();
				standShape.moveTo(0, height / 2, 0);
				standShape.lineTo(0, width / 4, 0);
				standShape.arc(width / 4, 0, width / 4, Math.PI + 0.1, Math.PI * 1.5);
				standShape.lineTo(width * 3/4, 0, 0);
				standShape.arc(0, width / 4, width / 4, -Math.PI / 2, 0);
				standShape.lineTo(width, height / 2, 0);
				
				const removeShape = new THREE.Shape(), standWidth = smallTile / 10, barY = height / 3;
				removeShape.moveTo(standWidth, barY - standWidth / 2, 0);
				removeShape.lineTo(standWidth, width / 4 + standWidth, 0);
				removeShape.arc(width / 4, 0, width / 4, Math.PI + 0.1, Math.PI * 1.5);
				removeShape.lineTo(width * 3/4 - standWidth, standWidth, 0);
				removeShape.arc(0, width / 4, width / 4, -Math.PI / 2 + 0.1, 0);
				removeShape.lineTo(width - standWidth, barY - standWidth / 2, 0);
				
				const removeShape2 = new THREE.Shape();
				removeShape2.moveTo(standWidth, height / 2 - standWidth, 0);
				removeShape2.lineTo(standWidth, barY + standWidth / 2, 0);
				removeShape2.lineTo(width - standWidth, barY + standWidth / 2, 0);
				removeShape2.lineTo(width - standWidth, height / 2 - standWidth, 0);

				standShape.holes.push(removeShape, removeShape2);
				
				geometry = new THREE.ExtrudeGeometry(standShape, { 
					depth: 0.01, 
					bevelEnabled: true, 
					bevelSegments: 2, 
					steps: 2, 
					bevelSize: 0.01, 
					bevelThickness: 0.01 
				});

				const stand = new THREE.Mesh(geometry, material);
				stand.rotation.x = -mirror.rotation.x * 2;
				stand.position.set(0, height / 2 * (1 - Math.cos(Math.PI / 6)), -height * Math.sin(Math.PI / 12));

				stand.receiveShadow = true;
				stand.castShadow = true;

				mirror.add(stand);

				mirror.receiveShadow = true;
				mirror.castShadow = true;

				const mirrorGroup = new THREE.Group();
				mirrorGroup.add(mirror);
				mirrorGroup.position.set(x, y, z);
				mirrorGroup.scale.set(scale, scale, scale);
				mirrorGroup.rotation.set(rotX, rotY, rotZ);

				return mirrorGroup;
			}
		</script>
		
	</body>
</html>


